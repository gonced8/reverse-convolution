<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Can you recover a blurred image?</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Can you recover a blurred image?</h1>
</header>
<section data-field="subtitle" class="p-summary">
Explanation on how to reverse an image convolution.
</section>
<section data-field="body" class="e-content">
<section name="d027" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="ceac" id="ceac" class="graf graf--h3 graf--leading graf--title">Can you recover a blurred image?</h3><p name="4c41" id="4c41" class="graf graf--p graf-after--h3">I was watching a video by Grant Sanderson (aka 3Blue1Brown) about convolutions, image processing, and the Julia programming language (awesome language!) when someone asked this question.</p><figure name="992b" id="992b" class="graf graf--figure graf--iframe graf-after--p"><iframe src="https://www.youtube.com/embed/8rrHTtUzyZA?start=878&amp;feature=oembed&amp;start=878" width="700" height="393" frameborder="0" scrolling="no"></iframe><figcaption class="imageCaption">The video by Grant Sanderson. I recommend it very much!</figcaption></figure><p name="87ab" id="87ab" class="graf graf--p graf-after--figure">He answered (correctly) that he didn’t think so, because we’d be losing information. However, I thought a little more about the question and figured that it would actually be possible if the output image had the same size as the input one! This way, the output has enough pixels/information to recover the original one.</p><p name="f32f" id="f32f" class="graf graf--p graf-after--p">First, I should start by explaining what a convolution is and how it can be used to blur an image. If you want a thorough explanation, I suggest the video above, but if you want a quick one, I got you. So, a convolution is a mathematical operation that, when applied to images, can be seen as a filter applied to it.</p><figure name="b084" id="b084" class="graf graf--figure graf--layoutOutsetLeft graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 244px; max-height: 259px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 106.1%;"></div><img class="graf-image" data-image-id="0*8TKcMYQe2vkFMA9i" data-width="244" data-height="259" alt="GIF of the implementation of a convolution operation on an image" src="https://cdn-images-1.medium.com/max/600/0*8TKcMYQe2vkFMA9i"></div><figcaption class="imageCaption">Image from GitHub: <a href="https://github.com/vdumoulin" data-href="https://github.com/vdumoulin" class="markup--anchor markup--figure-anchor" rel="author noopener" target="_blank">vdumoulin</a>/<a href="https://github.com/vdumoulin/conv_arithmetic" data-href="https://github.com/vdumoulin/conv_arithmetic" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">conv_arithmetic</a> .</figcaption></figure><p name="5361" id="5361" class="graf graf--p graf-after--figure">In this animation, we can see an example of a convolution of an image with a filter/kernel. The original image would be the blue matrix, the kernel the sliding dark blue matrix, and the output the greenish-blue matrix.</p><p name="d07b" id="d07b" class="graf graf--p graf-after--p">The convolution is obtained by multiplying the overlapping kernel and image and summing the products. The following equations may help: given an image <em class="markup--em markup--p-em">x</em> and a kernel <em class="markup--em markup--p-em">k</em>, the result of the convolution will be<em class="markup--em markup--p-em"> y</em>,</p><figure name="e723" id="e723" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 544px; max-height: 120px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 22.1%;"></div><img class="graf-image" data-image-id="0*4UPoqlLoLSc7mWWf" data-width="544" data-height="120" alt="convolution(x[4, 4], k[3, 3]) = y[2, 2]" src="https://cdn-images-1.medium.com/max/800/0*4UPoqlLoLSc7mWWf"></div></figure><p name="3afb" id="3afb" class="graf graf--p graf-after--figure">with</p><figure name="ed40" id="ed40" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 105px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 15%;"></div><img class="graf-image" data-image-id="0*0-0BQ5JYqlWz-rG1" data-width="1000" data-height="150" alt="Expressions for each element of y, as a sum of products of x and k." src="https://cdn-images-1.medium.com/max/800/0*0-0BQ5JYqlWz-rG1"></div></figure><p name="b3a4" id="b3a4" class="graf graf--p graf-after--figure">If you already knew how convolutions on images worked, maybe this system of equations isn’t too scary. If you didn’t, don’t worry, you won’t have to remember it, that’s the program job! A useful representation is to interpret the convolution as a matrix multiplication, which isn’t too difficult to write from the equations above:</p><figure name="3b77" id="3b77" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 211px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 30.099999999999998%;"></div><img class="graf-image" data-image-id="0*hUvic7_jZbv6OU7w" data-width="1000" data-height="301" alt="Convolution of x and k in matrix form." src="https://cdn-images-1.medium.com/max/800/0*hUvic7_jZbv6OU7w"></div></figure><p name="0de7" id="0de7" class="graf graf--p graf-after--figure">equivalent to the matrix equation</p><figure name="135d" id="135d" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 179px; max-height: 23px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 12.8%;"></div><img class="graf-image" data-image-id="0*YE4henZDj10tP3PR" data-width="179" data-height="23" alt="A[4 x 16] x[16 x 1] = y[4 x 1]" src="https://cdn-images-1.medium.com/max/800/0*YE4henZDj10tP3PR"></div></figure><p name="db1c" id="db1c" class="graf graf--p graf-after--figure">With this representation, it seems that knowing <em class="markup--em markup--p-em">A</em> and <em class="markup--em markup--p-em">y</em>, then <em class="markup--em markup--p-em">x</em> could be calculated by solving the equation above. However, since <em class="markup--em markup--p-em">A</em> has more columns than rows, the system is said to be undetermined, which means that we can’t obtain only one solution.</p><p name="83b1" id="83b1" class="graf graf--p graf-after--p">I started by saying that, to be possible to reverse a convolution, the input and output sizes would have to be the same. In matrix form, this would correspond to <em class="markup--em markup--p-em">A </em>being square (same number of rows and columns), allowing us to invert it and calculate <em class="markup--em markup--p-em">x</em> as</p><figure name="9340" id="9340" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 104px; max-height: 26px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 25%;"></div><img class="graf-image" data-image-id="0*ZBqMHjO_ZJqKulvK" data-width="104" data-height="26" alt="x = A^-1 * y" src="https://cdn-images-1.medium.com/max/800/0*ZBqMHjO_ZJqKulvK"></div></figure><p name="aae9" id="aae9" class="graf graf--p graf-after--figure">Now, our input is 4x4 and the output is 2x2. How can we obtain an output with the same size as the input? One way would be to add a padding to the input image, for example, 0-padding,</p><figure name="ced9" id="ced9" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 175px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 24.9%;"></div><img class="graf-image" data-image-id="0*UWLp_J_MU6OP4hAL" data-width="718" data-height="179" alt="convolution(x[4, 4], k[3, 3] with 0-padding of 1) = y[3, 3]" src="https://cdn-images-1.medium.com/max/800/0*UWLp_J_MU6OP4hAL"></div></figure><p name="93a0" id="93a0" class="graf graf--p graf-after--figure">This way, the output would be 4x4 like the original input. In detail, for this simple case of a convolution with padding, the output dimensions can be calculated as,</p><figure name="4544" id="4544" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 509px; max-height: 22px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 4.3%;"></div><img class="graf-image" data-image-id="0*7yd6wVwO0G1Qw4lg" data-width="509" data-height="22" alt="out size = in size + 2 * padding — kernel size + 1" src="https://cdn-images-1.medium.com/max/800/0*7yd6wVwO0G1Qw4lg"></div></figure><p name="b30c" id="b30c" class="graf graf--p graf-after--figure">If we want the input and output to have the same size, then the padding has to be,</p><figure name="8d5d" id="8d5d" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 274px; max-height: 51px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 18.6%;"></div><img class="graf-image" data-image-id="0*A0DEUF53A1QfzYvl" data-width="274" data-height="51" alt="padding = (kernel size — 1) / 2" src="https://cdn-images-1.medium.com/max/800/0*A0DEUF53A1QfzYvl"></div></figure><p name="317b" id="317b" class="graf graf--p graf-after--figure">which yields an important condition: the kernel size has to be odd since the padding is an integer value.</p><p name="86c3" id="86c3" class="graf graf--p graf-after--p">This convolution can also be represented as a matrix multiplication as the one above, but I’ll spare you the boredom of reading it since the dimensions would be much larger. One would write the equations of the convolution associated with each entry of <em class="markup--em markup--p-em">y </em>and then structure it as a matrix multiplication as above.</p><figure name="d29e" id="d29e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 195px; max-height: 23px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 11.799999999999999%;"></div><img class="graf-image" data-image-id="0*FGdRTkhLecX1sBGD" data-width="195" data-height="23" alt="A[16 x 16] x[16 x 1] = y[16 x 1]" src="https://cdn-images-1.medium.com/max/800/0*FGdRTkhLecX1sBGD"></div></figure><p name="b8db" id="b8db" class="graf graf--p graf-after--figure">Notice that despite the padded input being 6x6, corresponding to 36 elements, only 4x4 of those elements are unique and unknown variables. Therefore, <em class="markup--em markup--p-em">x</em> in the equation can be only 16x1, instead of 36x1.</p><p name="915b" id="915b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">To solve for <em class="markup--em markup--p-em">x </em>and reverse the convolution, one only needs to know <em class="markup--em markup--p-em">A</em> and <em class="markup--em markup--p-em">y</em>. To construct <em class="markup--em markup--p-em">A</em>, one needs to know the kernel used for the convolution and the type of padding used.</strong></p><p name="ad2e" id="ad2e" class="graf graf--p graf-after--p">Now, how could this be used?</p><p name="4489" id="4489" class="graf graf--p graf-after--p">An image can be blurred by doing a convolution. For example, a Gaussian Blur is obtained by convolving an image with a kernel/filter that has a Gaussian distribution with the largest value at the center and values that sum to 1. An example would be the kernel</p><figure name="0d0e" id="0d0e" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 225px; max-height: 90px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 40%;"></div><img class="graf-image" data-image-id="0*5F_FsFAhGNbcNy12" data-width="225" data-height="90" alt="Example of a 3x3 Gaussian kernel." src="https://cdn-images-1.medium.com/max/800/0*5F_FsFAhGNbcNy12"></div></figure><p name="1122" id="1122" class="graf graf--p graf-after--figure">I did a simple implementation of this problem in Julia to check that it is, in fact possible, to reverse the convolution, which you can review and use at the link below.</p><div name="7001" id="7001" class="graf graf--mixtapeEmbed graf-after--p"><a href="https://github.com/gonced8/reverse-convolution" data-href="https://github.com/gonced8/reverse-convolution" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/gonced8/reverse-convolution"><strong class="markup--strong markup--mixtapeEmbed-strong">gonced8/reverse-convolution</strong><br><em class="markup--em markup--mixtapeEmbed-em">Notebook in Julia (Pluto.jl) showing how to reverse a convolution, such as a Gaussian Blur. GitHub is home to over 50…</em>github.com</a><a href="https://github.com/gonced8/reverse-convolution" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="d57a9a824cef996b32531e6960974f68" data-thumbnail-img-id="0*pzOq4DadAll4XzIN" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*pzOq4DadAll4XzIN);"></a></div><p name="7b64" id="7b64" class="graf graf--p graf-after--mixtapeEmbed">So I started by blurring an image with a Gaussian Blur. I did a convolution of the original one with a Gaussian kernel and used replicate padding (values outside the original image are set to the nearest border value, instead of 0).</p><figure name="6e34" id="6e34" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 540px; max-height: 180px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 33.300000000000004%;"></div><img class="graf-image" data-image-id="1*8JBCvd6yRtAuQDfjtuXdLw.png" data-width="540" data-height="180" alt="original image on the left and blurred image on the right" src="https://cdn-images-1.medium.com/max/800/1*8JBCvd6yRtAuQDfjtuXdLw.png"></div><figcaption class="imageCaption">Original image on the left and blurred one on the right.</figcaption></figure><p name="5b38" id="5b38" class="graf graf--p graf-after--figure">Since I knew the kernel used, I was able to construct the matrix <em class="markup--em markup--p-em">A</em> and then solve for <em class="markup--em markup--p-em">x</em>. The results are as expected: the reconstructed image is exactly equal to the original one.</p><figure name="3e40" id="3e40" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 540px; max-height: 180px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 33.300000000000004%;"></div><img class="graf-image" data-image-id="1*_HzBseYyUID0xu0dfl1r6Q.png" data-width="540" data-height="180" src="https://cdn-images-1.medium.com/max/800/1*_HzBseYyUID0xu0dfl1r6Q.png"></div><figcaption class="imageCaption">Blurred image on the left and reconstructed one on the right.</figcaption></figure><p name="28af" id="28af" class="graf graf--p graf-after--figure">Feel free to check the implementation linked above and verify that the original image was not used in the reconstruction.</p><p name="c52a" id="c52a" class="graf graf--p graf-after--p">Now, this 100% reconstruction is only possible because the kernel and padding used are known. What happens if we use a kernel that is not exactly the same as the one used to blur the original image?</p><figure name="d8cd" id="d8cd" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 540px; max-height: 180px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 33.300000000000004%;"></div><img class="graf-image" data-image-id="1*bs-R0Vxmqaf8diR_9v31ZA.png" data-width="540" data-height="180" alt="Blurred image on the left and reconstructed on the right. Reconstructed is still blurry and has artifacts/stripes." src="https://cdn-images-1.medium.com/max/800/1*bs-R0Vxmqaf8diR_9v31ZA.png"></div><figcaption class="imageCaption">Blurred image on the left and reconstructed one on the right, when not using the exact kernel.</figcaption></figure><p name="2d99" id="2d99" class="graf graf--p graf-after--figure">And what if we assume 0-padding when replicate padding was used?</p><figure name="07dc" id="07dc" class="graf graf--figure graf-after--p"><div class="aspectRatioPlaceholder is-locked" style="max-width: 540px; max-height: 180px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 33.300000000000004%;"></div><img class="graf-image" data-image-id="1*19FU42cKIyBCxSHnQcw-Dg.png" data-width="540" data-height="180" alt="Blurred image on the left and reconstructed on the right. Reconstructed is like a psychedelic noise, nowhere similar." src="https://cdn-images-1.medium.com/max/800/1*19FU42cKIyBCxSHnQcw-Dg.png"></div><figcaption class="imageCaption">Blurred image on the left and reconstructed one on the right, when not assuming the exact padding.</figcaption></figure><p name="e4e8" id="e4e8" class="graf graf--p graf-after--figure">As we can see, if we don’t know the kernel and padding used, then we’re not able to reconstruct the original image. In this sense, it can almost be seen as an encryption problem: if we know the “key”, then we’re able to reconstruct the original message without any loss or additional noise.</p><p name="c022" id="c022" class="graf graf--p graf-after--p">Reconstructing the original image is also a very expensive task since matrix <em class="markup--em markup--p-em">A</em> grows very fast depending on the size of the original image. If the original image was 4x4, then A would be 16x16 — the number of elements scale with N².</p><p name="8bac" id="8bac" class="graf graf--p graf-after--p">Hope you liked this brief explanation and found it interesting. I surely did and it was a very good way to learn more about Julia, convolutions, image processing, and linear algebra. If you have any questions and/or find any error, feel free to share.</p><blockquote name="f3a1" id="f3a1" class="graf graf--pullquote graf-after--p">As a goodbye note, I think we don’t need to worry about people reversing our blurred photos, for now.</blockquote><figure name="0761" id="0761" class="graf graf--figure graf-after--pullquote"><div class="aspectRatioPlaceholder is-locked" style="max-width: 576px; max-height: 128px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 22.2%;"></div><img class="graf-image" data-image-id="1*ivrLJkywymfnW01MWldwgQ.png" data-width="576" data-height="128" alt="Blurred image on the left and reconstructed one on the right. Reconstructed image is of a monkey." src="https://cdn-images-1.medium.com/max/800/1*ivrLJkywymfnW01MWldwgQ.png"></div><figcaption class="imageCaption">Blurred image on the left and reconstructed one on the right.</figcaption></figure><figure name="95a5" id="95a5" class="graf graf--figure graf-after--figure graf--trailing"><div class="aspectRatioPlaceholder is-locked" style="max-width: 700px; max-height: 700px;"><div class="aspectRatioPlaceholder-fill" style="padding-bottom: 100%;"></div><img class="graf-image" data-image-id="1*-twAey3xMDV8u8F5OsIiIg.png" data-width="720" data-height="720" data-focus-x="50" data-focus-y="51" data-is-featured="true" alt="Blurred and reconstructed image of woman named Lena." src="https://cdn-images-1.medium.com/max/800/1*-twAey3xMDV8u8F5OsIiIg.png"></div><figcaption class="imageCaption">Featured image.</figcaption></figure></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@gonced8" class="p-author h-card">Gonçalo Raposo</a> on <a href="https://medium.com/p/61bbcaa969d5"><time class="dt-published" datetime="2020-09-13T20:30:14.599Z">September 13, 2020</time></a>.</p><p><a href="https://medium.com/@gonced8/can-you-recover-a-blurred-image-61bbcaa969d5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on September 14, 2020.</p></footer></article></body></html>